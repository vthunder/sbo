# SRS (Structured Reference String) Generation

This document describes how the KZG SRS points used in `sbo-crypto` were generated.

## Background

SBO uses KZG polynomial commitments to verify data availability proofs from Avail. The KZG scheme requires a Structured Reference String (SRS) - a set of elliptic curve points derived from a trusted setup ceremony.

## Source

The SRS points come from Avail's trusted setup, which is derived from Filecoin's Powers of Tau ceremony (challenge_19):

- **Avail SRS repository**: https://github.com/availproject/avail-core
- **Source file**: `kate/src/g1_g2_1024.txt`
- **Ceremony**: Filecoin Powers of Tau (challenge_19)

## File Format

The `g1_g2_1024.txt` file has the following format:

```
1024          # Number of G1 points
513           # Number of G2 points
<g1_point_0>  # 96 hex chars = 48 bytes compressed BLS12-381 G1
<g1_point_1>
...
<g1_point_1023>
<g2_point_0>  # 192 hex chars = 96 bytes compressed BLS12-381 G2
...
<g2_point_512>
```

Each G1 point is a compressed BLS12-381 curve point (48 bytes).
Each G2 point is a compressed BLS12-381 curve point (96 bytes).

## What We Embed

For SBO's use case (verifying Avail row commitments), we only need the first 256 G1 points. This is because:

1. Avail's data matrix has at most 256 columns
2. Row polynomials have degree < 256
3. KZG commitment verification only needs G1 points (G2 is for the verification key, which we get from the proof)

## Extraction Process

The embedded SRS in `sbo-crypto/src/srs_data.rs` was generated by:

1. **Download** the source file from Avail's repository
2. **Parse** the hex-encoded G1 points (lines 3-1026)
3. **Convert** to Rust byte array format
4. **Embed** the first 256 points (12,288 bytes total)

### Python Script (Reconstruction)

If you need to regenerate the embedded SRS:

```python
#!/usr/bin/env python3
"""Extract and format SRS G1 points from Avail's g1_g2_1024.txt"""

def extract_srs_points(input_file: str, num_points: int = 256) -> bytes:
    """Extract first N G1 points from Avail SRS file."""
    with open(input_file, 'r') as f:
        lines = f.readlines()

    # Skip header lines (count of G1, count of G2)
    num_g1 = int(lines[0].strip())
    num_g2 = int(lines[1].strip())

    print(f"File contains {num_g1} G1 points and {num_g2} G2 points")

    # G1 points start at line 2
    g1_points = []
    for i in range(min(num_points, num_g1)):
        hex_str = lines[2 + i].strip()
        point_bytes = bytes.fromhex(hex_str)
        assert len(point_bytes) == 48, f"G1 point {i} has wrong size: {len(point_bytes)}"
        g1_points.append(point_bytes)

    return b''.join(g1_points)

def format_rust_array(data: bytes, name: str = "SRS_G1_POINTS") -> str:
    """Format bytes as Rust static array."""
    lines = [f"pub static {name}: [u8; {len(data)}] = ["]

    # Format as rows of 16 bytes
    for i in range(0, len(data), 16):
        chunk = data[i:i+16]
        hex_vals = ', '.join(f'0x{b:02x}' for b in chunk)
        lines.append(f"    {hex_vals},")

    lines.append("];")
    return '\n'.join(lines)

if __name__ == "__main__":
    import sys
    input_file = sys.argv[1] if len(sys.argv) > 1 else "g1_g2_1024.txt"

    points = extract_srs_points(input_file, num_points=256)
    print(f"Extracted {len(points)} bytes ({len(points) // 48} points)")

    rust_code = format_rust_array(points)
    print(rust_code[:500] + "...")
```

## Verification

To verify the embedded points are correct:

1. The first G1 point should be the generator: `97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb`
2. All points should decompress successfully via `blst_p1_uncompress`
3. Points should match Avail's KZG verification results

## Security Note

The security of KZG commitments relies on the trusted setup ceremony being performed correctly and the toxic waste (secret tau) being destroyed. The Filecoin Powers of Tau ceremony involved thousands of participants, making it practically impossible for an attacker to reconstruct tau.

## References

- [Avail Core Repository](https://github.com/availproject/avail-core)
- [KZG Polynomial Commitments](https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html)
- [Filecoin Trusted Setup](https://filecoin.io/blog/posts/trusted-setup/)
- [BLS12-381 Curve](https://hackmd.io/@benjaminion/bls12-381)
